= Node Classification
:level: Intermediate
:page-level: Intermediate
:author: Clair Sullivan
:category: graph-data-science
:tags: graph-data-science, graph-algorithms, machine-learning
:description: This guide covers machine learning-based node classification using the Neo4j Data Science Library.
:page-aliases: ROOT:graph-algorithms.adoc

.Goals
[abstract]
In this guide, we will learn about graph embeddings.

.Prerequisites
[abstract]
Please have link:/download[Neo4j^] (version 4.2.3 or later) and link:/download-center/#algorithms[Graph Data Science Library^] (version 1.5 or later) downloaded and installed to use graph embeddings.  You should also have https://github.com/neo4j-contrib/neo4j-apoc-procedures[APOC^] (version 4.1.0.6 or later).

[role=expertise {level}]
{level}

[#node-prediction]
== What is node prediction?

Node prediction is a machine learning concept whereby existing node and edge properties can be used to train a model that will learn node classifications.  This model can then be applied to one or a set of nodes to predict their node classifications.

Node classification is based on logistic regression, which is dicussed here:

*** insert link to some generalized node classification guide

Penalty :: L1 norm used to prevent overfitting of the training data

[NOTE]
====
The code examples used in this guide can be found in https://github.com/AliciaFrame/ML_with_GDS[this GitHub repository^].  

[#marvel-dataset]
== Marvel Universe dataset

In this example we will be using a dataset from the comics and movies associated with the Marvel Universe.  This dataset can be found ***here***.  It contains *** characters and *** relationships connecting them.  The properties associated with the characters are ***.  We will be using this dataset to try and predict, off of a series of characters for training purposes, which characters are X-Men and which are not.

***Insert graph schema***

This diagram was generated by running `CALL db.schema.visualization()` in the link:/developer/neo4j-browser[Neo4j Browser] after importing the data.

In this next section we will demonstrating how to run the node classifcation algorithm on two different models: one where we use the properties associated with each character and conver them to tabular format for training and one where we use the FastRP graph embedding algorithm to create vector embeddings for the training and test set in order to predict node classes.  ***insert link to FastRP***

***insert some relevant definitions***

We will begin by loading in the data to the database from a series of CSV files available online.  This can be done with the following query:

[source, cypher]
----
//1. Load data - from https://gist.github.com/tomasonjo/fbc6d617c3f6476a3a825b5dd22fd29a

CALL apoc.schema.assert({Character:['name']},{Comic:['id'], Character:['id'], Event:['id'], Group:['id']});

LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/tomasonjo/blog-datasets/main/Marvel/heroes.csv" as row
CREATE (c:Character)
SET c += row;

LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/tomasonjo/blog-datasets/main/Marvel/groups.csv" as row
CREATE (c:Group)
SET c += row;

LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/tomasonjo/blog-datasets/main/Marvel/events.csv" as row
CREATE (c:Event)
SET c += row;

LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/tomasonjo/blog-datasets/main/Marvel/comics.csv" as row
CREATE (c:Comic)
SET c += apoc.map.clean(row,[],["null"]);

LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/tomasonjo/blog-datasets/main/Marvel/heroToComics.csv" as row
MATCH (c:Character{id:row.hero})
MATCH (co:Comic{id:row.comic})
MERGE (c)-[:APPEARED_IN]->(co);

LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/tomasonjo/blog-datasets/main/Marvel/heroToEvent.csv" as row
MATCH (c:Character{id:row.hero})
MATCH (e:Event{id:row.event})
MERGE (c)-[:PART_OF_EVENT]->(e);

LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/tomasonjo/blog-datasets/main/Marvel/heroToGroup.csv" as row
MATCH (c:Character{id:row.hero})
MATCH (g:Group{id:row.group})
MERGE (c)-[:PART_OF_GROUP]->(g);

LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/tomasonjo/blog-datasets/main/Marvel/heroToHero.csv" as row
MATCH (s:Character{id:row.source})
MATCH (t:Character{id:row.target})
CALL apoc.create.relationship(s,row.type, {}, t) YIELD rel
RETURN distinct 'done';

LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/tomasonjo/blog-datasets/main/Marvel/heroStats.csv" as row
MATCH (s:Character{id:row.hero})
CREATE (s)-[:HAS_STATS]->(stats:Stats)
SET stats += apoc.map.clean(row,['hero'],[]);

LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/tomasonjo/blog-datasets/main/Marvel/heroFlight.csv" as row
MATCH (s:Character{id:row.hero})
SET s.flight = row.flight;

MATCH (s:Stats)
WITH keys(s) as keys LIMIT 1
MATCH (s:Stats)
UNWIND keys as key
CALL apoc.create.setProperty(s, key, toInteger(s[key]))
YIELD node
RETURN distinct 'done';
----

This query creates a series of nodes and their labels and properties: `Comic`, `Character`, `Stats`.


[#use-cases-graph-embeddings]
== Use cases for graph embeddings



There are several use cases that are well suited for graph embeddings:

* We can visually explore the data by reducing the embeddings to 2 or 3 dimensions with the help of algorithms like https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding[t-distributed stochastic neighbor embedding^] (t-SNE) and https://en.wikipedia.org/wiki/Principal_component_analysis[Principle Component Analysis^] (PCA).

* We could build a kNN similarity graph from the embeddings.
The similarity graph could then be used to make recommendations as part of a k-Nearest Neighbors query.

* We can use the embeddings as the features to feed into a machine learning model, rather than generating those features by hand.
In this use case, embeddings can be considered an implementation of https://en.wikipedia.org/wiki/Feature_learning[Representational Learning^].

[#supported-graph-embeddings]
== Neo4j's graph embeddings

The Neo4j link:/graph-data-science-library[Graph Data Science Library^] supports several graph embedding algorithms.

[opts=header]
|===
| Name | Speed | Supports node properties? | Implementation details
| link:#random-projection[Random Projection] | Fast |   No | Linear Algebra
| link:#node2Vec[node2Vec] |  Intermediate |  No | Neural Network
| link:#graph-sage[GraphSAGE] | Slow |   Yes | Neural Network
|===

All the embedding algorithms work on a monopartite undirected input graph.

[#random-projection]
Random Projection ::
The Random Projection embedding uses sparse random projections to generate embeddings.
It is an implementation of the https://arxiv.org/pdf/1908.11512.pdf[FastRP algorithm^].
It is the fastest of the embedding algorithms and can therefore be useful for obtaining baseline embeddings.
The embeddings it generates are often equally performant as more complex algorithms that take longer to run.

link:/docs/graph-data-science/1.3-preview/algorithms/alpha/fastrp/fastrp/[Read Random Projection reference documentation^, role="medium button"]

[#node2Vec]
node2Vec ::
https://arxiv.org/pdf/1607.00653.pdf[node2Vec^] computes embeddings based on biased random walks of a node's neighborhood.
The algorithm trains a single-layer feedforward neural network, which is used to predict the likelihood that a node will occur in a walk based on the occurrence of another node.
node2Vec has parameters that can be tuned to control whether the random walks behave more like breadth first or depth first searches.
This tuning allows the embedding to either capture homophily (similar embeddings capture network communities) or structural equivalence (similar embeddings capture similar structural roles of nodes).

link:/docs/graph-data-science/1.3-preview/algorithms/node-embeddings/node2vec/[Read node2Vec reference documentation^, role="medium button"]

[#graph-sage]
GraphSAGE ::
This https://arxiv.org/pdf/1706.02216.pdf[algorithm^] is the only one that supports node properties.
Training embeddings that include node properties can be useful for including information beyond the topology of the graph, like meta data, attributes, or the results of other graph algorithms.
GraphSAGE differs from the other algorithms in that it learns a function to calculate an embedding rather than training individual embeddings for each node.

link:/docs/graph-data-science/1.3-preview/algorithms/alpha/graph-sage/[Read GraphSAGE reference documentation^, role="medium button"]
